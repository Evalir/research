# Generated by protoc_gen_nim. Do not edit!

import base64
import intsets
import json
import strutils

import nimpb/nimpb
import nimpb/json as nimpb_json

type
    vac_ns_NameUpdate* = ref vac_ns_NameUpdateObj
    vac_ns_NameUpdateObj* = object of Message
        name: string
        content: seq[byte]
    vac_ns_Query* = ref vac_ns_QueryObj
    vac_ns_QueryObj* = object of Message
        name: string
    vac_ns_Content* = ref vac_ns_ContentObj
    vac_ns_ContentObj* = object of Message
        data: seq[byte]
    vac_ns_Response* = ref vac_ns_ResponseObj
    vac_ns_ResponseObj* = object of Message
        data: seq[byte]

proc newvac_ns_Query*(): vac_ns_Query
proc newvac_ns_Query*(data: string): vac_ns_Query
proc newvac_ns_Query*(data: seq[byte]): vac_ns_Query
proc writevac_ns_Query*(stream: Stream, message: vac_ns_Query)
proc readvac_ns_Query*(stream: Stream): vac_ns_Query
proc sizeOfvac_ns_Query*(message: vac_ns_Query): uint64
proc toJson*(message: vac_ns_Query): JsonNode
proc parsevac_ns_Query*(obj: JsonNode): vac_ns_Query

proc newvac_ns_NameUpdate*(): vac_ns_NameUpdate
proc newvac_ns_NameUpdate*(data: string): vac_ns_NameUpdate
proc newvac_ns_NameUpdate*(data: seq[byte]): vac_ns_NameUpdate
proc writevac_ns_NameUpdate*(stream: Stream, message: vac_ns_NameUpdate)
proc readvac_ns_NameUpdate*(stream: Stream): vac_ns_NameUpdate
proc sizeOfvac_ns_NameUpdate*(message: vac_ns_NameUpdate): uint64
proc toJson*(message: vac_ns_NameUpdate): JsonNode
proc parsevac_ns_NameUpdate*(obj: JsonNode): vac_ns_NameUpdate

proc newvac_ns_Response*(): vac_ns_Response
proc newvac_ns_Response*(data: string): vac_ns_Response
proc newvac_ns_Response*(data: seq[byte]): vac_ns_Response
proc writevac_ns_Response*(stream: Stream, message: vac_ns_Response)
proc readvac_ns_Response*(stream: Stream): vac_ns_Response
proc sizeOfvac_ns_Response*(message: vac_ns_Response): uint64
proc toJson*(message: vac_ns_Response): JsonNode
proc parsevac_ns_Response*(obj: JsonNode): vac_ns_Response

proc newvac_ns_Content*(): vac_ns_Content
proc newvac_ns_Content*(data: string): vac_ns_Content
proc newvac_ns_Content*(data: seq[byte]): vac_ns_Content
proc writevac_ns_Content*(stream: Stream, message: vac_ns_Content)
proc readvac_ns_Content*(stream: Stream): vac_ns_Content
proc sizeOfvac_ns_Content*(message: vac_ns_Content): uint64
proc toJson*(message: vac_ns_Content): JsonNode
proc parsevac_ns_Content*(obj: JsonNode): vac_ns_Content

proc fullyQualifiedName*(T: typedesc[vac_ns_Query]): string = "vac.ns.Query"

proc readvac_ns_QueryImpl(stream: Stream): Message = readvac_ns_Query(stream)
proc writevac_ns_QueryImpl(stream: Stream, msg: Message) = writevac_ns_Query(stream, vac_ns_Query(msg))
proc toJsonvac_ns_QueryImpl(msg: Message): JsonNode = toJson(vac_ns_Query(msg))
proc fromJsonvac_ns_QueryImpl(node: JsonNode): Message = parsevac_ns_Query(node)

proc vac_ns_QueryProcs*(): MessageProcs =
    result.readImpl = readvac_ns_QueryImpl
    result.writeImpl = writevac_ns_QueryImpl
    result.toJsonImpl = toJsonvac_ns_QueryImpl
    result.fromJsonImpl = fromJsonvac_ns_QueryImpl

proc newvac_ns_Query*(): vac_ns_Query =
    new(result)
    initMessage(result[])
    result.procs = vac_ns_QueryProcs()
    result.name = ""

proc clearname*(message: vac_ns_Query) =
    message.name = ""

proc setname*(message: vac_ns_Query, value: string) =
    message.name = value

proc name*(message: vac_ns_Query): string {.inline.} =
    message.name

proc `name=`*(message: vac_ns_Query, value: string) {.inline.} =
    setname(message, value)

proc sizeOfvac_ns_Query*(message: vac_ns_Query): uint64 =
    if len(message.name) > 0:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.name)
    result = result + sizeOfUnknownFields(message)

proc writevac_ns_Query*(stream: Stream, message: vac_ns_Query) =
    if len(message.name) > 0:
        protoWriteString(stream, message.name, 1)
    writeUnknownFields(stream, message)

proc readvac_ns_Query*(stream: Stream): vac_ns_Query =
    result = newvac_ns_Query()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setname(result, protoReadString(stream))
        else: readUnknownField(stream, result, tag)

proc toJson*(message: vac_ns_Query): JsonNode =
    result = newJObject()
    if len(message.name) > 0:
        result["name"] = %message.name

proc parsevac_ns_Query*(obj: JsonNode): vac_ns_Query =
    result = newvac_ns_Query()
    var node: JsonNode
    if obj.kind != JObject:
        raise newException(nimpb_json.ParseError, "object expected")
    node = getJsonField(obj, "name", "name")
    if node != nil and node.kind != JNull:
        setname(result, parseString(node))

proc serialize*(message: vac_ns_Query): string =
    let
        ss = newStringStream()
    writevac_ns_Query(ss, message)
    result = ss.data

proc newvac_ns_Query*(data: string): vac_ns_Query =
    let
        ss = newStringStream(data)
    result = readvac_ns_Query(ss)

proc newvac_ns_Query*(data: seq[byte]): vac_ns_Query =
    let
        ss = newStringStream(cast[string](data))
    result = readvac_ns_Query(ss)


proc fullyQualifiedName*(T: typedesc[vac_ns_NameUpdate]): string = "vac.ns.NameUpdate"

proc readvac_ns_NameUpdateImpl(stream: Stream): Message = readvac_ns_NameUpdate(stream)
proc writevac_ns_NameUpdateImpl(stream: Stream, msg: Message) = writevac_ns_NameUpdate(stream, vac_ns_NameUpdate(msg))
proc toJsonvac_ns_NameUpdateImpl(msg: Message): JsonNode = toJson(vac_ns_NameUpdate(msg))
proc fromJsonvac_ns_NameUpdateImpl(node: JsonNode): Message = parsevac_ns_NameUpdate(node)

proc vac_ns_NameUpdateProcs*(): MessageProcs =
    result.readImpl = readvac_ns_NameUpdateImpl
    result.writeImpl = writevac_ns_NameUpdateImpl
    result.toJsonImpl = toJsonvac_ns_NameUpdateImpl
    result.fromJsonImpl = fromJsonvac_ns_NameUpdateImpl

proc newvac_ns_NameUpdate*(): vac_ns_NameUpdate =
    new(result)
    initMessage(result[])
    result.procs = vac_ns_NameUpdateProcs()
    result.name = ""
    result.content = @[]

proc clearname*(message: vac_ns_NameUpdate) =
    message.name = ""

proc setname*(message: vac_ns_NameUpdate, value: string) =
    message.name = value

proc name*(message: vac_ns_NameUpdate): string {.inline.} =
    message.name

proc `name=`*(message: vac_ns_NameUpdate, value: string) {.inline.} =
    setname(message, value)

proc clearcontent*(message: vac_ns_NameUpdate) =
    message.content = @[]

proc setcontent*(message: vac_ns_NameUpdate, value: seq[byte]) =
    message.content = value

proc content*(message: vac_ns_NameUpdate): seq[byte] {.inline.} =
    message.content

proc `content=`*(message: vac_ns_NameUpdate, value: seq[byte]) {.inline.} =
    setcontent(message, value)

proc sizeOfvac_ns_NameUpdate*(message: vac_ns_NameUpdate): uint64 =
    if len(message.name) > 0:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfString(message.name)
    if len(message.content) > 0:
        result = result + sizeOfTag(2, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.content)
    result = result + sizeOfUnknownFields(message)

proc writevac_ns_NameUpdate*(stream: Stream, message: vac_ns_NameUpdate) =
    if len(message.name) > 0:
        protoWriteString(stream, message.name, 1)
    if len(message.content) > 0:
        protoWriteBytes(stream, message.content, 2)
    writeUnknownFields(stream, message)

proc readvac_ns_NameUpdate*(stream: Stream): vac_ns_NameUpdate =
    result = newvac_ns_NameUpdate()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setname(result, protoReadString(stream))
        of 2:
            expectWireType(wireType, WireType.LengthDelimited)
            setcontent(result, protoReadBytes(stream))
        else: readUnknownField(stream, result, tag)

proc toJson*(message: vac_ns_NameUpdate): JsonNode =
    result = newJObject()
    if len(message.name) > 0:
        result["name"] = %message.name
    if len(message.content) > 0:
        result["content"] = %message.content

proc parsevac_ns_NameUpdate*(obj: JsonNode): vac_ns_NameUpdate =
    result = newvac_ns_NameUpdate()
    var node: JsonNode
    if obj.kind != JObject:
        raise newException(nimpb_json.ParseError, "object expected")
    node = getJsonField(obj, "name", "name")
    if node != nil and node.kind != JNull:
        setname(result, parseString(node))
    node = getJsonField(obj, "content", "content")
    if node != nil and node.kind != JNull:
        setcontent(result, parseBytes(node))

proc serialize*(message: vac_ns_NameUpdate): string =
    let
        ss = newStringStream()
    writevac_ns_NameUpdate(ss, message)
    result = ss.data

proc newvac_ns_NameUpdate*(data: string): vac_ns_NameUpdate =
    let
        ss = newStringStream(data)
    result = readvac_ns_NameUpdate(ss)

proc newvac_ns_NameUpdate*(data: seq[byte]): vac_ns_NameUpdate =
    let
        ss = newStringStream(cast[string](data))
    result = readvac_ns_NameUpdate(ss)


proc fullyQualifiedName*(T: typedesc[vac_ns_Response]): string = "vac.ns.Response"

proc readvac_ns_ResponseImpl(stream: Stream): Message = readvac_ns_Response(stream)
proc writevac_ns_ResponseImpl(stream: Stream, msg: Message) = writevac_ns_Response(stream, vac_ns_Response(msg))
proc toJsonvac_ns_ResponseImpl(msg: Message): JsonNode = toJson(vac_ns_Response(msg))
proc fromJsonvac_ns_ResponseImpl(node: JsonNode): Message = parsevac_ns_Response(node)

proc vac_ns_ResponseProcs*(): MessageProcs =
    result.readImpl = readvac_ns_ResponseImpl
    result.writeImpl = writevac_ns_ResponseImpl
    result.toJsonImpl = toJsonvac_ns_ResponseImpl
    result.fromJsonImpl = fromJsonvac_ns_ResponseImpl

proc newvac_ns_Response*(): vac_ns_Response =
    new(result)
    initMessage(result[])
    result.procs = vac_ns_ResponseProcs()
    result.data = @[]

proc cleardata*(message: vac_ns_Response) =
    message.data = @[]

proc setdata*(message: vac_ns_Response, value: seq[byte]) =
    message.data = value

proc data*(message: vac_ns_Response): seq[byte] {.inline.} =
    message.data

proc `data=`*(message: vac_ns_Response, value: seq[byte]) {.inline.} =
    setdata(message, value)

proc sizeOfvac_ns_Response*(message: vac_ns_Response): uint64 =
    if len(message.data) > 0:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.data)
    result = result + sizeOfUnknownFields(message)

proc writevac_ns_Response*(stream: Stream, message: vac_ns_Response) =
    if len(message.data) > 0:
        protoWriteBytes(stream, message.data, 1)
    writeUnknownFields(stream, message)

proc readvac_ns_Response*(stream: Stream): vac_ns_Response =
    result = newvac_ns_Response()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setdata(result, protoReadBytes(stream))
        else: readUnknownField(stream, result, tag)

proc toJson*(message: vac_ns_Response): JsonNode =
    result = newJObject()
    if len(message.data) > 0:
        result["data"] = %message.data

proc parsevac_ns_Response*(obj: JsonNode): vac_ns_Response =
    result = newvac_ns_Response()
    var node: JsonNode
    if obj.kind != JObject:
        raise newException(nimpb_json.ParseError, "object expected")
    node = getJsonField(obj, "data", "data")
    if node != nil and node.kind != JNull:
        setdata(result, parseBytes(node))

proc serialize*(message: vac_ns_Response): string =
    let
        ss = newStringStream()
    writevac_ns_Response(ss, message)
    result = ss.data

proc newvac_ns_Response*(data: string): vac_ns_Response =
    let
        ss = newStringStream(data)
    result = readvac_ns_Response(ss)

proc newvac_ns_Response*(data: seq[byte]): vac_ns_Response =
    let
        ss = newStringStream(cast[string](data))
    result = readvac_ns_Response(ss)


proc fullyQualifiedName*(T: typedesc[vac_ns_Content]): string = "vac.ns.Content"

proc readvac_ns_ContentImpl(stream: Stream): Message = readvac_ns_Content(stream)
proc writevac_ns_ContentImpl(stream: Stream, msg: Message) = writevac_ns_Content(stream, vac_ns_Content(msg))
proc toJsonvac_ns_ContentImpl(msg: Message): JsonNode = toJson(vac_ns_Content(msg))
proc fromJsonvac_ns_ContentImpl(node: JsonNode): Message = parsevac_ns_Content(node)

proc vac_ns_ContentProcs*(): MessageProcs =
    result.readImpl = readvac_ns_ContentImpl
    result.writeImpl = writevac_ns_ContentImpl
    result.toJsonImpl = toJsonvac_ns_ContentImpl
    result.fromJsonImpl = fromJsonvac_ns_ContentImpl

proc newvac_ns_Content*(): vac_ns_Content =
    new(result)
    initMessage(result[])
    result.procs = vac_ns_ContentProcs()
    result.data = @[]

proc cleardata*(message: vac_ns_Content) =
    message.data = @[]

proc setdata*(message: vac_ns_Content, value: seq[byte]) =
    message.data = value

proc data*(message: vac_ns_Content): seq[byte] {.inline.} =
    message.data

proc `data=`*(message: vac_ns_Content, value: seq[byte]) {.inline.} =
    setdata(message, value)

proc sizeOfvac_ns_Content*(message: vac_ns_Content): uint64 =
    if len(message.data) > 0:
        result = result + sizeOfTag(1, WireType.LengthDelimited)
        result = result + sizeOfBytes(message.data)
    result = result + sizeOfUnknownFields(message)

proc writevac_ns_Content*(stream: Stream, message: vac_ns_Content) =
    if len(message.data) > 0:
        protoWriteBytes(stream, message.data, 1)
    writeUnknownFields(stream, message)

proc readvac_ns_Content*(stream: Stream): vac_ns_Content =
    result = newvac_ns_Content()
    while not atEnd(stream):
        let
            tag = readTag(stream)
            wireType = wireType(tag)
        case fieldNumber(tag)
        of 0:
            raise newException(InvalidFieldNumberError, "Invalid field number: 0")
        of 1:
            expectWireType(wireType, WireType.LengthDelimited)
            setdata(result, protoReadBytes(stream))
        else: readUnknownField(stream, result, tag)

proc toJson*(message: vac_ns_Content): JsonNode =
    result = newJObject()
    if len(message.data) > 0:
        result["data"] = %message.data

proc parsevac_ns_Content*(obj: JsonNode): vac_ns_Content =
    result = newvac_ns_Content()
    var node: JsonNode
    if obj.kind != JObject:
        raise newException(nimpb_json.ParseError, "object expected")
    node = getJsonField(obj, "data", "data")
    if node != nil and node.kind != JNull:
        setdata(result, parseBytes(node))

proc serialize*(message: vac_ns_Content): string =
    let
        ss = newStringStream()
    writevac_ns_Content(ss, message)
    result = ss.data

proc newvac_ns_Content*(data: string): vac_ns_Content =
    let
        ss = newStringStream(data)
    result = readvac_ns_Content(ss)

proc newvac_ns_Content*(data: seq[byte]): vac_ns_Content =
    let
        ss = newStringStream(cast[string](data))
    result = readvac_ns_Content(ss)


